# lld

紹介、開発を始めた経緯など

## だれ

プログラマー
- lldリンカ
- 8ccコンパイラ

## lldとは

- llvmのサブプロジェクト
- ELF, COFF, Mach-O, wasmをサポート
  - wasm は experimental どういうリンカであるべきかを議論していくべき　
- とにかく高速

### 事例

- FreeBSDの次期バージョンの /usr/bin/ld は lld
- Chrome[windows/linux/android]
- firefox[windows]
- rust[arm]
  - 常に全ての環境で動く状態でしかビルドできない
- 大規模webサイトの裏側
- その他多数

### リンカ

オブジェクトファイルを1つの実行可能ファイルやDSO(DLL)にまとめるやつ

### パフォーマンス

gnuのgoldより2倍以上早い
「今後機能が増えていくにつれて遅くなるんじゃないか？」
そんなことなく、むしろoptimizerなどによって早くなった

### コード規模

lld/ELF だいたい2.9万行
gold 20.6万行

### リンカの仕事

- コンパイラが開けた関数のアドレスを実際に埋める

### lldの扱うデータ

Chrome(with debug)の場合

13,000,000リロケーションを解釈しなければいけない
もし1リロケーションに1μ秒掛かると、合計で13秒かかる

### 開発のきっかけ

システムズっぽいチームの社内転職を試みた
「cコンパイラを書いた」「何故」
「コンパイラとリンカを作らないといけなかった、どっちがいい？」
リンカは論理的には簡単そうだと思った
windowsリンカを作ることに

### 何処から手を付ければよいか?

Linkers & Loaders

これだけでは全然作れない

なんか間違ってても頻度がない
`Cannot execute binary file.`
OSが実行できるなんでもないものを作る

空のファイルをアセンブリで作って、それを解釈する
少しずつ理解していき、それと同じものを自分の書いたプログラムで吐き出させる
ちょっとずつ発展させる

### 問題

遅い

#### ファイルフォーマットの違い

現在対応している4種
リンクという概念は共有だが、細かいところはあらゆる点で微妙に異なる、いろいろな方向で発展していったし

#### コードを統一するとどうなる

抽象化のためのコードをたくさん書かなければいけない
- WindowsとUnixではファイル検索順が違うのでカスタマイズできるようにするとか
- 中間フォーマットに変換するコストが非常に高い

### 書き直しを決意

メーリングリストに書いたら喧々諤々となってしまった
新しく書き始めたら前より10倍早く動作するようになった
書き直しの成功を見て新たな開発者がプロジェクトに加わってきた

#### リデザインポイント

- 難しくしすぎない
- 不自然な最適化はしない、自然と性能が出るように書く
  - 遅いコードをコードで早くすることは出来ない
  - データ構造を正しく決める
- 抽象化しすぎない

##### データ構造のデザインポイント

- 名前付けのためのハッシュテーブルのルックアップを極力へらす
- 必要な操作が自然に行えるようなデータ構造
- メモリのローカリティにも配慮

### ELFリンカ開発

急にパッチがきた

### lldにおけるマルチターゲット対応

全てのターゲットでデザインは共有するが、コードは共有しない
lldは4つのほぼ独立したリンカが1つの実行ファイルに入っている
似たようなコードを書くことになるがそれは許容する
- 似ているようだが責務が違う
  - 単一責任原則的にも許容されそうに思う 

### 早くてシンプルなコードを書くために

良いデータ構造にする: データが先、コードは後
2回書く: 1度目のけいけんを2度目に活かす
最適化する箇所を最小に留める
速いプログラムが自然に書けるのが速いコード
- 読みやすさを重視して書く
プロジェクトのオーナーが責任を持ってコードをきれいに保つ

## メモリ改善

### 動的メモリ管理

- メモリのアロケートしている
lldが動的にメモリ上に作成したデータはほとんど最後まで必要になる
bump pointer allocator
たとえば8byte欲しい場合今使ってる終端から8byte使う領域を増やす

など

### deterministic build

ビルド結果は毎回おなじであるべき
stringの順番、実行ファイル的には逆でいいけど逆だと嫌だ

# おわりに

- 問題についてよく考え、自分が良いと思うやり方を試してみる
- 存在しない問題を作り出して解決するのではなくもともとの問題を直接解決できないか考える
- 「Unixの開発環境の標準リンカになる」という大きな目標も、挑戦しないヒトが多いだけで意外と実現可能だったりするので、挑戦してみよう。
