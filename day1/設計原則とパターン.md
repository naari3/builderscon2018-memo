# 設計原則とパターン

## だれ

classiのヒト
- 学校教育をICTで変えよう
- 学校向けコミュニティウェア

webdbでいろいろやってる
- データ構造の基礎知識とか
- web開発の起訴の基礎

フィードバックくださいとのこと

## 前回までのあらすじ

前回までのあらすじ

「この設計がこの問題に最適だ」とどう判断するか？

設計原則とパターンを使って立ち向かう

## ところで

設計パターン、抽象的な話が多い

ビジネスロジックとは

2人のいう抽象化の意味がちょっと違う

責務なんて考え方しだいでは？
- e.g. 「全てのクラスの物事を担うものです。」

「DRY原則いいぞ」「共通化するぞ」 そしてUtilクラスが作られる

辛い

## そもそも設計とは

有る問題に対して解決策となるような構造を与えるアクティビティ　「マルチパラダイムデザイン」
- ひとかたまりになった問題を分割するということ

### どう分割するの

闇雲に分割するのか？
- だめ

闇雲にデザインパターンを適用するのは設計ではない

たとえばDBを扱うシステム、どういう目的で分割するか？
- テーブル毎
- CURD毎
- 別の支店

### 設計とは

複数の分割構造の選択肢から今ある問題に対して最適な選択肢を選び出すこと

## デザインパターンと設計原則

- デザインパターン
  - 分割構造、実現方法のカタログ
- 設計原則
  - その分割構造が良い構造かどうかを判断するための指針

パターン使ったり構造を作ったりする
↑↓
設計原則でレビュー、問題に対して良い解決かどうか見直す

この循環を回すのが「設計」なのでは？

## 実例で見る

- サービスの一機能の掲示板
- watchしてるpostにコメントがあったらマイページにお知らせ通知
  - notifiacationてブルに書き込み
- お知らせには掲示板の書き込み以外の通知もある
- push通知を設定しているならpush通知する

メソッド内で
if aaa == :comment
  hoge
else aaa == :star
  hoge

なんでいけないのか言語化できる？
- 出来ないなら暗黙知
  - これはセンス、センスがよくないとなんでいけないかわかっらん
- チームの底力を上げるならちゃんと設計レビューなどで言語化出来ないといけない

設計原則がここで役立つ

単一責任原則
開放閉鎖原則
凝集度と結合度

### 単一責任原則

ひとつのもじゅーるに一つの原則

有るクラスを変更する理由が2つ以上あってはいけない
「Aに対する仕様変更でもBに対する変更でも影響があるみたいなクラスはだめ」

クラスを変更する理由
- コメントが付いた時の通知の振る舞いが変わった
- スターが付いた時の通知の振る舞いが変わった
これは仕事しすぎ

### 開放閉鎖原則

拡張に対して開いている
- 機能追加する際に他のクラスに影響がないようにしている

修正に対して閉じている
- 内部を修正したときにそのクラスに依存しているクラスに影響がないようにする

拡張に対して開いていないとは
- asiatoをつけるとき
- 新しい通知を増えたときこのメソッドを変えないと駄目もうひとつelseifを追加する、拡張に対して閉じている

修正に対して閉じていないとは
- アカウントから引落しする CustomerSuspender
- suspend状態のためにcustomerクラスのプロパティをいじっている
  - customerクラスをかえるたびに変更が走る
  - suspendのメソッドをcustomerにうつす、suspedが変わっても大丈夫


### 凝集度と結合度

凝集度は高く
- 関連するものは一つにまとめる
- いっこの仕様変更で言っろんなクラスに影響でるのは低いという状態
結合度は低く
- 片方の変更がもう片方に影響をあたえにくいようにする

凝集度の低い例
- CustomerSuspender
  - customerのsuspenderの話もcustomerにかかれている
  - これはsuspend情報をcustomerにうつすといい

結合度の高い
- 命令を呼ぶだけなので良くなった

### 最初のコードは

神classが全部やっててモジュール化されてない

### 今回は

- 設計減速を使って良いコードかどうか検討した
- なんであかんのか言語化できた
- 良い原則かどうかを検討するための武器

根拠をもって説明できる

## 駄目だったコードをやり直すために

パターン使ったり構造を作ったりする
↑↓
設計原則でレビュー、問題に対して良い解決かどうか見直す

今レビューして悪かったので他の構造を検討

ユースケース
- サービスの一機能の掲示板
- watchしてるpostにコメントがあったらマイページにお知らせ通知
  - notifiacationてブルに書き込み

↑これobserverパターンでは

良い気がするけど設計原則と照らし合わせてみよう

単一責任原則について見てみる
コメントに関することも通知に関することもcommentObserverが担っている
- 単一責任原則OK


開放閉鎖原則
starを追加しようとする
- 追加
  - commentObserverにもcommentにも変更はいらない
  - 開放している
- 修正する
  - buildNotificationBodyだけ変えれば良い
  - 閉鎖している
- 開放閉鎖原則


結合度

commentObserver
- commentに依存しているが
  - commentの内部が変わってもobserverを変えなくていいならOK # メモ
- create呼んでるだけ

凝集度

rubyにはobserverモジュールある
つかうことで
- ボタンを書き換えずにボタンハンドラーを増やしたり変えたりできる
- ボタンの振る舞いを墓b単ハンドラーを変更せずに追加、変更ができる

observerパターンは依存の方向が逆になる

ほかの通知機能が現れることはあるが、コメントが通知することは変わるのか？commentObserverがどんどん変わったり増えたりすることある？
コメントの仕様が変わったときおしらせが変わらないことはあるのか？
- observerも変える必要が出てくるのでは

コメントの変更でcommentObserverも変えなければいけなくなるというのは凝集度低くなっている
- コメントもobserverも返る必要が出てくる

observerなしでコメントモデルで済ませれば良いんじゃないのか？


こういうところを見ると凝集度は駄目

observerなしで考えてみる
単一責任原則 
２つの理由でモデルが変えられないこと
今回は問題ない

開放閉鎖原則
starを追加する、問題ない
コメントの修正、コメントの範囲だけで済むので問題ない

凝集度
OK

### まとめ

構造を考える、設計原則を使ってレビューする、構造を考える、レビューする

## 未解決問題

push通知が解決してない
状況次第である
- コメント付いたときにpshはあるけどstarがついたときは通知しない？
  - この場合、コメントモデルがやったほうがいい
  - もしNotidicationで持たせるとすると、if comment esle star、、、など地獄っぽくなる
- 必ず通知する
  - こえんとにやらせると通知が変わるたびにコメントもstarも直さなければいけなくなってつらい、凝集度低い

### 設計は問題次第

問題によって

何処が変更されるかを把握しないと(変わりやすいかを見ないと)変更によってどう変わるかどうかがわかりにくい
- 単一責任原則について、Aの変更Bの変更はいいがCの変更は？

KISS原則
  - Keep it simple, stupid 
YAGNI原則
  - You ain't gonna need it
  - 何処が変わるかわからん時は、現在わかっている範囲のみで極力シンプルにしておくべき

こうすることで

EnterpriseQualityCoding/FizzBuzzEnterpriseEdition

「どこが変わってもいいように」書かれたFizzBuzz、もんだいを捉えそこねた抽象化

問題を捉えそこねたまま原則に合わせることは無意味

## 全体のまとめ

設計は複数の選択肢から良い構造をえらぶ行為
どこがかわる、どこがかわらないのかの分析がいる
わからんならシンプルにやっていく

複数の選択肢を用意する、繰り返して適切な構造を割り当てる、どこが変わりやすいかを確認する

# Q & A

- Q.原則、こういう原則はこういうフェーズに使えるのでは？などの
  - YAGNIなどはコードを書き始める前

  - A. SOLID原則
    - SOは抽象度が高い、LIDは抽象度が低い、LIDは開発中に使用したり
    - 

- Q. 
  - 単一責任原則あるクラスを変更する場合は2つ以上の理由があってはならない
    - 通知の本文が変わる
    - コメントだけでなくタイトルも
      - この２つの理由で変わりうるのでは
- A.
  - 例えばcommentNotificationBodyBuilderなどがいて、そいつに持たせても良いのではないかな
